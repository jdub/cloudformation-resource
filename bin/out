#!/bin/sh
set -eu -o pipefail
exec 3>&1 1>&2

jq . < /dev/stdin > /tmp/input

SRC=$1

STACK=$(jq -r '.source.stack // empty' /tmp/input)

export AWS_ACCESS_KEY_ID=$(jq -r '.source.aws_access_key_id // empty' /tmp/input)
export AWS_SECRET_ACCESS_KEY=$(jq -r '.source.aws_secret_access_key // empty' /tmp/input)
export AWS_DEFAULT_REGION=$(jq -r '.source.region // empty' /tmp/input)

TEMPLATE=$(jq -r '.params.template // empty' /tmp/input)

CAPABILITIES="--capabilities $(jq -r '[.params.capabilities // empty] | flatten | join(" ")' /tmp/input)"


fill_params() {
  local IPATH=$1
  local INPUT=$2
  (echo '{'
  jq -r "$IPATH"' | to_entries | map([.key, .value | tostring])[] | join(" ")' "$INPUT" | while read KEY FILE; do
    if [ -f "$FILE" ]; then
      echo -n '  "'$KEY'": '
      if jq -M . "$FILE" 2> /dev/null; then :; else
        jq -MR '.' "$FILE"
      fi
      echo ","
    else
      echo '  "'$KEY'": "'$FILE'",'
    fi
  done
  echo '"null":null}') | jq -M 'del(.null)'
}


# Should we upload or reference a template?
if expr match "$TEMPLATE" 'https\?:' > /dev/null; then
  UPLOAD="--template-url $TEMPLATE"
else
  UPLOAD="--template-file file://${SRC}/${TEMPLATE}"
fi

# Should we create or update the stack? (Check existence by way of get-template.)
if aws cloudformation get-template --stack-name "$STACK" > /tmp/template.json 2> /dev/null; then
  ACTION=update-stack
  WAIT=stack-update-complete

  # Should we tell CloudFormation to use the previous template?
  jq --sort-keys '.TemplateBody' /tmp/template.json > /tmp/cur.json
  jq --sort-keys . $SRC/$TEMPLATE > /tmp/new.json

  if cmp -s /tmp/cur.json /tmp/new.json; then
    UPLOAD="--use-previous-template"
  fi

  aws cloudformation describe-stacks \
    --stack-name "$STACK" \
    --query 'Stacks[0]' > /tmp/stack.json

  # Merge stack parameters with provided parameters
  fill_params '.params.parameters' /tmp/input > /tmp/params.json
  jq '.Parameters | map({key: .ParameterKey, value: $params[(.ParameterKey)]}) | map({ParameterKey: .key} + if .value then {ParameterValue: .value} else {UsePreviousValue: true} end)' /tmp/stack.json --argfile params /tmp/params.json > /tmp/stack-params.json

else
  ACTION=create-stack
  WAIT=stack-create-complete

  # Produce stack parameters
  fill_params '.params.create' /tmp/input > /tmp/params.json
  jq 'to_entries | map({ParameterKey: .key, ParameterValue: .value})' /tmp/params.json > /tmp/stack-params.json
fi


TOUCHED=$(date -u +%FT%T.000Z)
COMPLETE=false

STACK_ID=$(aws cloudformation $ACTION \
  --stack-name "$STACK" $UPLOAD \
  --parameters file:///tmp/stack-params.json \
  $CAPABILITIES --query 'StackId' --output text)

while [ "$COMPLETE" == "false" ]; do
  aws cloudformation describe-stack-events \
    --stack-name "$STACK_ID" \
    --max-items 20 \
    --query 'StackEvents' | jq 'map(select(.Timestamp > "'$TOUCHED'"))' > /tmp/events.json

  TOUCHED=$(jq -r '.[0].Timestamp // "'$TOUCHED'"' /tmp/events.json)
  COMPLETE=$(jq -r '.[0].ResourceStatus // "" | endswith("_COMPLETE")' /tmp/events.json)

  jq -r 'def pad($l): .[:$l] + ($l - (. | length)) * " "; reverse | map([(.ResourceStatus | pad(30)), (.ResourceType | pad(30)), (.LogicalResourceId | pad(25)), .ResourceStatusReason])[] | join(" | ")' /tmp/events.json

  if [ "$COMPLETE" == "false" ]; then
    sleep 3
  fi
done


# if CREATE_COMPLETE or UPDATE_COMPLETE then output version, otherwise explode
aws cloudformation describe-stacks \
  --stack-name "$STACK" \
  --query 'Stacks[0]' > /tmp/output

jq '{version: {updated: (.LastUpdatedTime // .CreationTime)}, metadata: {StackStatus, CreationTime, Description} | to_entries | map({name: .key, value: .value})}' /tmp/output >&3
